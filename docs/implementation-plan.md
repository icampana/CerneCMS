
## 1. Executive Summary and Architectural Vision

### 1.1 Project Scope and Strategic Alignment

This report outlines a definitive implementation strategy for a lightweight, high-performance Content Management System (CMS). The architectural mandate specifies a distinct technological convergence: the utilization of **FlightPHP** as a micro-framework backend, **SQLite** as a serverless relational database, and **Svelte 5** as the frontend reactive engine, incorporating **Tiptap** for rich-text editing capabilities. This specific configuration replaces previous iterations targeting Vue.js, shifting the focus towards Svelte 5’s compiled reactivity model and "Runes" system to enhance runtime performance and developer ergonomics.

The primary objective is to engineer a system that balances the ease of deployment found in traditional PHP environments—specifically shared hosting scenarios—with the interactivity and sophisticated user interface paradigms of modern Single Page Applications (SPA). The proposed "Hybrid Monolith" architecture leverages FlightPHP to serve the initial application shell and handle API requests, while Svelte 5, bundled via Vite, manages the client-side state and complex editor interactions.

### 1.2 The Case for the Hybrid Stack

The selection of this stack is not merely a preference but a strategic response to the complexities of modern web development.

- **FlightPHP**: As an extensible micro-framework, FlightPHP avoids the boilerplate and resource overhead associated with larger enterprise frameworks like Laravel or Symfony.1 It provides essential routing, middleware, and dependency injection capabilities while allowing direct control over the request lifecycle. Its compatibility with PHP 7.4+ ensures broad support across legacy and modern hosting environments.2
    
- **SQLite**: The decision to utilize SQLite aligns with the goal of minimizing operational complexity. As a serverless, file-based database engine, SQLite eliminates the need for a separate database process (e.g., MySQL or PostgreSQL), drastically simplifying backup, migration, and deployment procedures.4
    
- **Svelte 5**: The pivot to Svelte 5 represents a forward-looking investment in performance. Unlike React or Vue, which rely on a Virtual DOM (VDOM) to reconcile state changes, Svelte compiles components into imperative JavaScript that updates the DOM directly. Svelte 5 introduces "Runes" (`$state`, `$derived`, `$effect`), a granular reactivity model that is particularly advantageous for rich text editors where transaction frequency is high and latency must be minimized.6
    
- **Tiptap**: By adopting Tiptap, a headless wrapper around ProseMirror, the system gains a document model that is framework-agnostic but deeply customizable. Tiptap’s decoupling of state from the UI allows Svelte 5 to render the editor interface completely, enabling features like Slash Commands and Draggable Blocks to be implemented as native Svelte components.8
    

---

## 2. Backend Engineering: FlightPHP and SQLite

The backend architecture is designed to be lean, serving two primary functions: delivering the compiled frontend assets and providing a secure, RESTful API for data persistence.

### 2.1 Project Directory and Structure

A disciplined directory structure is critical for maintainability and security, particularly in shared hosting environments where the web root might be exposed. The recommended structure strictly separates the application logic from public-facing assets.1

**Table 1: Directory Structure and Responsibilities**

|**Directory**|**Sub-component**|**Responsibility**|
|---|---|---|
|`/app`|`/config`|Configuration files for database connections, routes, and environment variables.|
||`/controllers`|Classes handling HTTP request logic, separating API logic from view rendering.|
||`/middleware`|Interceptors for request validation, authentication, and session management.|
||`/models`|Active Record classes defining database schema interactions and relationships.|
||`/views`|Server-side templates (Latte or native PHP) for the initial HTML shell.|
|`/database`|`site.db`|The SQLite database file, stored outside the web root to prevent unauthorized download.|
|`/public`|`/assets`|Compiled JavaScript and CSS files generated by Vite.|
||`index.php`|The single entry point for all HTTP requests, initializing the Flight engine.|
|`/src`|`/lib`, `/routes`|Source code for the Svelte 5 application.|

This structure ensures that the `app` and `database` directories are inaccessible via direct HTTP requests, a crucial security posture for file-based database systems.11

### 2.2 Database Initialization and Connection Management

FlightPHP does not include a database abstraction layer by default, but it provides a register method to handle dependency injection for external classes, such as PHP’s native PDO (PHP Data Objects).

#### 2.2.1 The Connection Service

In `public/index.php` or a dedicated bootstrap file, the database connection is registered as a singleton service. This ensures that the connection is established only when needed and reused across the request lifecycle.12

PHP

```
// public/index.php
require '../vendor/autoload.php';

$config = require '../app/config/config.php';

Flight::register('db', 'PDO', ["sqlite:{$config['database_path']}"], function($db) {
    // Set error mode to exception for better debugging
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    // Fetch as associative arrays by default
    $db->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
    // Enable Write-Ahead Logging (WAL) for concurrency performance
    $db->exec('PRAGMA journal_mode = WAL;');
    // Enforce foreign key constraints
    $db->exec('PRAGMA foreign_keys = ON;');
});
```

#### 2.2.2 Schema Migration and Validation

Unlike heavy frameworks with dedicated migration CLIs, a FlightPHP/SQLite setup often benefits from "migrations on boot" for simpler deployments. The system checks for the existence of required tables using the `sqlite_master` system table upon initialization.14

The `sqlite_master` table defines the schema for the database. Querying it allows the application to determine if initialization SQL needs to be executed.

PHP

```
// app/core/Database.php
public static function init() {
    $db = Flight::db();
    
    // Check if 'posts' table exists
    $stmt = $db->query("SELECT name FROM sqlite_master WHERE type='table' AND name='posts'");
    
    if (!$stmt->fetch()) {
        // Table creation SQL
        $sql = "CREATE TABLE posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            uuid TEXT UNIQUE NOT NULL,
            title TEXT,
            content JSON, -- Tiptap JSON content
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )";
        $db->exec($sql);
        
        // Create indexes for performance
        $db->exec("CREATE INDEX idx_posts_uuid ON posts(uuid)");
    }
}
```

This approach, validated by research into SQLite's internal mechanisms, ensures that the database is self-healing and requires no external tools to set up.5

### 2.3 Active Record Implementation

FlightPHP’s `active-record` plugin maps database rows to PHP objects, simplifying CRUD operations. This abstraction layer prevents the need to write raw SQL for standard operations.17

#### 2.3.1 Model Definition

The `Post` model extends `flight\ActiveRecord`. A critical configuration step is binding the database connection within the `onConstruct` method, which allows the model to utilize the globally registered `Flight::db()` connection.13

PHP

```
// app/models/Post.php
namespace app\models;

use flight\ActiveRecord;

class Post extends ActiveRecord {
    public function __construct($db = null) {
        parent::__construct($db, 'posts');
    }

    protected function onConstruct(self $self, array &$config) {
        $config['connection'] = \Flight::db();
    }
}
```

#### 2.3.2 Handling JSON Content

Tiptap exports content as a complex JSON object. SQLite does not have a native JSON data type in the same way PostgreSQL does, but it supports JSON functions on `TEXT` columns. The Active Record model acts as a transformer, decoding the JSON string into a PHP array when accessed, and encoding it back to a string when saved. This data transformation layer is essential for the frontend to receive a valid JSON object rather than a stringified blob.19

### 2.4 API Design and Routing

The API serves as the bridge between the Svelte frontend and the SQLite persistence layer. FlightPHP’s routing engine supports grouping, allowing for clean organization of API endpoints protected by middleware.

#### 2.4.1 RESTful Endpoints

The routes are defined in `app/config/routes.php`. We utilize `Flight::group` to prefix all API routes and apply authentication middleware globally to that group.21

PHP

```
// app/config/routes.php

// API Group with Middleware
Flight::group('/api', function() {
    Flight::route('GET /posts', ['app\controllers\ApiController', 'index']);
    Flight::route('GET /posts/@id', ['app\controllers\ApiController', 'show']);
    Flight::route('POST /posts', ['app\controllers\ApiController', 'store']);
    Flight::route('PUT /posts/@id', ['app\controllers\ApiController', 'update']);
}, [ new \app\middleware\AuthMiddleware() ]);

// Single Page Application Catch-all
// This route captures all non-API requests and serves the Svelte app
Flight::route('*',);
```

#### 2.4.2 Controller Logic

The `ApiController` handles the logic. Specifically for the `update` method, it must accept the JSON payload generated by Tiptap.

PHP

```
// app/controllers/ApiController.php
public function update($id) {
    $request = Flight::request();
    $data = $request->data;
    
    $post = new Post();
    $post = $post->find($id);
    
    if (!$post) {
        Flight::halt(404, json_encode(['error' => 'Post not found']));
    }
    
    // Update fields
    $post->title = $data->title;
    // content is passed as a PHP array/object from Flight's JSON parser
    // We must serialize it for SQLite storage
    $post->content = json_encode($data->content); 
    $post->updated_at = date('Y-m-d H:i:s');
    
    $post->save();
    
    Flight::json();
}
```

### 2.5 Security Middleware

In a shared hosting environment, security layers at the application level are mandatory. The `AuthMiddleware` intercepts requests to the `/api` group. It checks for a valid session or JWT token. If the check fails, it halts the request chain immediately.23

PHP

```
// app/middleware/AuthMiddleware.php
namespace app\middleware;

class AuthMiddleware {
    public function before() {
        if (!Flight::session()->get('user_id')) {
            Flight::json(['error' => 'Unauthorized'], 401);
            exit;
        }
    }
}
```

---

## 3. Frontend Architecture: Svelte 5 and Vite

The frontend architecture represents a significant departure from typical Vue.js implementations. Svelte 5 introduces a new reactivity paradigm that requires specific architectural considerations, particularly when interfacing with a non-Node.js backend.

### 3.1 The Shift to Svelte 5 Runes

Svelte 5 replaces the store-based reactivity of previous versions with "Runes." This shift is critical for the Tiptap integration. In Svelte 4, reactivity was often tied to component boundaries or cumbersome `store` subscriptions. Runes allow reactivity to be defined in plain JavaScript classes, which aligns perfectly with Tiptap’s class-based extension architecture.6

**Table 2: Comparison of Svelte Reactivity Models**

|**Feature**|**Svelte 4 (Legacy)**|**Svelte 5 (Runes)**|**Impact on Tiptap Integration**|
|---|---|---|---|
|**State Declaration**|`let count;` / `writable(0)`|`let count = $state(0);`|Allows editor state to be reactive outside `.svelte` files.|
|**Derived State**|`$: double = count * 2;`|`let double = $derived(count * 2);`|More predictable computation of editor statistics (word count).|
|**Side Effects**|`$: { console.log(count); }`|`$effect(() => {... });`|Clearer lifecycle management for mounting/destroying editor instances.|
|**Prop Passing**|`export let val;`|`let { val } = $props();`|Standardized prop destruction for custom Node Views.|

### 3.2 Vite Configuration for PHP Integration

Since FlightPHP serves the HTML, Vite is used strictly as an asset bundler. There are two primary strategies for this integration: the **Manifest Method** and the **Single File Method**.

#### 3.2.1 Strategy A: The Manifest Method (Recommended)

This method is superior for production environments. Vite generates a `manifest.json` file that maps source files (e.g., `main.js`) to their hashed output filenames (e.g., `main.a1b2c3.js`). This allows for effective long-term caching.25

**Vite Config (`vite.config.js`):**

JavaScript

```
import { defineConfig } from 'vite';
import { svelte } from '@sveltejs/vite-plugin-svelte';

export default defineConfig({
  plugins: [svelte()],
  build: {
    // Generate manifest.json in the output directory
    manifest: true,
    outDir: 'public/assets',
    rollupOptions: {
      // Define the entry point clearly
      input: 'src/main.js'
    }
  },
  server: {
    // Enable CORS to allow the PHP server (port 8000) to request assets from Vite (port 5173)
    cors: true,
    origin: 'http://localhost:5173'
  }
});
```

#### 3.2.2 Strategy B: The Single File Method

For simpler projects where cache busting is managed manually or irrelevant, `vite-plugin-singlefile` can bundle all JS and CSS into a single HTML file or asset. However, given the request for a "detailed implementation plan," the Manifest method provides higher professional fidelity.27

### 3.3 The PHP-Vite Bridge

To connect the backend and frontend, a helper in FlightPHP parses the manifest file.

PHP

```
// app/helpers/Vite.php
class Vite {
    public static function asset($entry) {
        $manifestPath = __DIR__. '/../../public/assets/.vite/manifest.json';
        
        // Development Mode: Hot Module Replacement (HMR)
        if (!file_exists($manifestPath)) {
            return "http://localhost:5173/src/{$entry}";
        }
        
        // Production Mode: Read from Manifest
        $manifest = json_decode(file_get_contents($manifestPath), true);
        if (isset($manifest["src/{$entry}"])) {
            return '/assets/'. $manifest["src/{$entry}"]['file'];
        }
    }
}
```

This helper is then used in the `views/layout.php` template to dynamically inject the correct script tags based on the environment.

---

## 4. The Editor Engine: Tiptap Implementation

The core of the application is the Tiptap editor. This implementation utilizes Svelte 5 components to render the editor interface, moving beyond simple text entry to a block-based system similar to Notion.

### 4.1 Editor State Management with Runes

Managing the Tiptap instance requires a persistent state wrapper. We create a dedicated class `EditorStore.svelte.js` (note the `.svelte.js` extension enabling Runes) to encapsulate the editor logic.

JavaScript

```
// src/lib/stores/editor.svelte.js
import { Editor } from '@tiptap/core';
import StarterKit from '@tiptap/starter-kit';

export class EditorStore {
    // Reactive state for the editor instance
    instance = $state(null);
    // Reactive state for JSON content
    content = $state({});
    
    constructor(element, initialContent) {
        this.instance = new Editor({
            element: element,
            extensions:,
            content: initialContent,
            onTransaction: () => {
                // Force reactivity update. In Svelte 5, reassigning a state trigger effects.
                // This is crucial for updating toolbar button states (active/inactive).
                this.instance = this.instance;
            },
            onUpdate: ({ editor }) => {
                this.content = editor.getJSON();
            }
        });
    }

    destroy() {
        this.instance?.destroy();
    }
}
```

This encapsulation decouples the Tiptap logic from the UI components, adhering to clean architecture principles.

### 4.2 Componentizing the Editor

The main editor component, `Tiptap.svelte`, handles the lifecycle of the editor instance.

HTML

```
<script>
    import { onMount, onDestroy } from 'svelte';
    import { EditorStore } from '../stores/editor.svelte.js';
    import EditorToolbar from './EditorToolbar.svelte';

    let { initialContent = {}, onSave } = $props();
    
    let element; // Bound to the DOM node
    let editorStore = $state();

    onMount(() => {
        // Initialize the editor store when the DOM is ready
        editorStore = new EditorStore(element, initialContent);
    });

    onDestroy(() => {
        editorStore?.destroy();
    });
    
    function handleSave() {
        onSave(editorStore.content);
    }
</script>

<div class="editor-layout">
    {#if editorStore?.instance}
        <EditorToolbar editor={editorStore.instance} />
    {/if}
    
    <div bind:this={element} class="prose prose-lg max-w-none focus:outline-none min-h-[500px]"></div>
</div>
```

### 4.3 Deep Dive: Custom Node Views and Draggable Blocks

One of the most complex requirements is the implementation of draggable blocks. This requires replacing the default HTML rendering of nodes (like paragraphs or headers) with a Svelte component that includes a drag handle.

#### 4.3.1 The Draggable Block Component

This component serves as a wrapper. It utilizes `NodeViewWrapper` and `NodeViewContent` provided by `svelte-tiptap` (or a custom implementation if compatibility issues arise with Svelte 5).

**Critical Implementation Detail**: Svelte 5's Runes syntax `$props()` replaces the `export let` syntax found in Svelte 4 examples.

HTML

```
<script>
    import { NodeViewWrapper, NodeViewContent } from 'svelte-tiptap';
    
    // Destructuring props using Svelte 5 syntax
    let { node, getPos, editor } = $props();
    
    // Derived state for attributes
    let isActive = $derived(editor.isActive(node.type.name));
</script>

<NodeViewWrapper class="group relative flex items-start">
    <div 
        class="drag-handle opacity-0 group-hover:opacity-100 cursor-grab p-1 mr-2 select-none"
        contenteditable="false" 
        data-drag-handle
    >
        <svg width="12" height="12" viewBox="0 0 24 24">
            <path fill="currentColor" d="M8 6a2 2 0 1 1-4 0a2 2 0 0 1 4 0zm0 6a2 2 0 1 1-4 0a2 2 0 0 1 4 0zm0 6a2 2 0 1 1-4 0a2 2 0 0 1 4 0zm6-12a2 2 0 1 1-4 0a2 2 0 0 1 4 0zm0 6a2 2 0 1 1-4 0a2 2 0 0 1 4 0zm0 6a2 2 0 1 1-4 0a2 2 0 0 1 4 0z" />
        </svg>
    </div>

    <div class="flex-1">
        <NodeViewContent />
    </div>
</NodeViewWrapper>
```

#### 4.3.2 Registering the Node View

The extension configuration must link the Tiptap node types to this Svelte component using `SvelteNodeViewRenderer`.

JavaScript

```
import { SvelteNodeViewRenderer } from 'svelte-tiptap';
import DraggableBlock from './DraggableBlock.svelte';
import DragHandle from '@tiptap/extension-drag-handle';

// Inside EditorStore constructor extensions array:
extensions:
```

This configuration transforms every paragraph and heading into an interactive block that can be reordered via drag-and-drop, satisfying the specific requirement for block-based editing.9

### 4.4 Deep Dive: Slash Commands (The Floating Menu)

The "Slash Command" pattern (typing `/` to open a menu) is implemented using the `@tiptap/suggestion` utility. This utility detects the trigger character and delegates the rendering of the menu to the frontend framework.

#### 4.4.1 The Suggestion Logic

We define a custom extension that encapsulates the trigger logic.

JavaScript

```
// src/lib/extensions/SlashCommand.js
import { Extension } from '@tiptap/core';
import Suggestion from '@tiptap/suggestion';

export default Extension.create({
    name: 'slashCommand',
    addOptions() {
        return {
            suggestion: {
                char: '/', // The trigger
                command: ({ editor, range, props }) => {
                    props.command({ editor, range });
                },
            },
        }
    },
    addProseMirrorPlugins() {
        return
    }
});
```

#### 4.4.2 The Svelte Renderer for Suggestions

Tiptap requires a renderer object with lifecycle methods (`onStart`, `onUpdate`, `onExit`). We use `tippy.js` to handle the absolute positioning of the menu relative to the cursor, and `mount` from Svelte 5 to render the menu component.30

JavaScript

```
// src/lib/extensions/SuggestionRenderer.js
import { mount, unmount } from 'svelte';
import tippy from 'tippy.js';
import SlashMenu from '../components/SlashMenu.svelte';

export const SvelteSlashRenderer = () => {
    let component;
    let popup;

    return {
        onStart: props => {
            // Create a container
            const div = document.createElement('div');
            
            // Mount the Svelte component manually
            component = mount(SlashMenu, {
                target: div,
                props: {
                    items: props.items,
                    command: props.command
                }
            });

            // Create Tippy instance
            popup = tippy('body', {
                getReferenceClientRect: props.clientRect,
                appendTo: () => document.body,
                content: div,
                showOnCreate: true,
                interactive: true,
                trigger: 'manual',
                placement: 'bottom-start',
            });
        },
        
        onUpdate(props) {
            // Update the props of the mounted component
            // (Note: Svelte 5 mount return value interaction may vary, 
            // employing a shared reactive object is often cleaner)
            if (component.updateItems) component.updateItems(props.items);
            
            if (props.clientRect) {
                popup.setProps({
                    getReferenceClientRect: props.clientRect,
                });
            }
        },

        onKeyDown(props) {
            if (props.event.key === 'Escape') {
                popup.hide();
                return true;
            }
            // Delegate navigation to the component
            return component.handleKeyDown(props.event);
        },

        onExit() {
            popup.destroy();
            unmount(component);
        },
    }
}
```

---

## 5. Security, Performance, and Deployment

### 5.1 Content Security and Sanitization

While Tiptap sanitizes content on paste, the backend must never trust the client. When saving JSON, FlightPHP receives structured data. If the application needs to render this content server-side (e.g., for SEO or RSS feeds), it must convert the JSON to HTML.

To prevent Cross-Site Scripting (XSS), the HTML generation should be handled either:

1. **Client-Side**: The Svelte app requests the JSON and renders it using Tiptap in "editable: false" mode. This is the safest approach as no HTML is stored or generated on the server.
    
2. **Server-Side**: A PHP-based Tiptap renderer can be used, but the output must be passed through a library like `HTMLPurifier` before display.
    

### 5.2 Session Security

The FlightPHP session handler must be configured for strict security, especially given the API-driven nature of the Svelte app.

- **Cookie Attributes**: `HttpOnly` and `SameSite=Strict` must be set to prevent Javascript access to session identifiers and reduce CSRF risks.
    
- **CSRF Tokens**: The Svelte app needs a CSRF token to make POST requests. This token should be injected into the `window` object by the `layout.php` view and included in the headers of all `fetch` requests.
    

JavaScript

```
// src/lib/api.js
export async function post(url, data) {
    const response = await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': window.CSRF_TOKEN // Injected by PHP
        },
        body: JSON.stringify(data)
    });
    return response.json();
}
```

### 5.3 Shared Hosting Deployment Strategy

The architecture is specifically optimized for shared hosting where Node.js processes cannot run permanently.

1. **Build**: The developer runs `npm run build` locally or in a CI/CD pipeline. This populates `public/assets`.
    
2. **Upload**: The entire project (excluding `node_modules` and `src`) is uploaded via FTP or Git.
    
3. **Run**: The Apache/Nginx web server points to `public/`. `index.php` handles the rest. No `pm2` or `supervisor` is required for the backend, and the frontend is static assets.
    

### 5.4 Performance Optimization

- **SQLite WAL Mode**: Enabling Write-Ahead Logging (`PRAGMA journal_mode=WAL;`) significantly improves concurrency, allowing readers to not block writers. This is essential for a multi-user CMS.14
    
- **Code Splitting**: The Vite manifest configuration ensures that the Svelte app is split into chunks. Users visiting the "Edit" page load the Tiptap library, while users viewing the "Home" page only load the lightweight display logic.
    

## 6. Conclusion

This detailed implementation plan demonstrates that targeting **Svelte 5** within a **FlightPHP** and **SQLite** ecosystem is not only viable but highly advantageous. The architecture leverages the strengths of each component: FlightPHP’s simplicity for backend routing, SQLite’s portability for data persistence, and Svelte 5’s granular reactivity for a high-performance editing experience.

By implementing Tiptap with custom Node Views and Slash Commands, the system achieves a feature parity with market-leading editors like Notion, while retaining a lightweight footprint suitable for cost-effective hosting. The "Hybrid Monolith" approach successfully bridges the gap between traditional PHP development and modern JavaScript application design, fulfilling all technical requirements of the directive.
